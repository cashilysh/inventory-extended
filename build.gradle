plugins {
    id 'fabric-loom' version '1.10-SNAPSHOT'
    id 'maven-publish'
}

version = '1.0.0'
group = 'inventoryextended'


task updateVersionMappings {
    description = "Downloads the latest version mappings from the Linkie API."
    doLast {
        def apiUrl = "https://linkieapi.shedaniel.me/api/versions/all"
        def mappingsFile = file('version_mappings.json')
       
        println "Fetching latest version mappings from ${apiUrl}..."
        try {
            // Connect to the URL and get the text content
            def jsonText = new URL(apiUrl).text
            // Save the downloaded content to the local file
            mappingsFile.text = jsonText
            println "Successfully saved latest mappings to ${mappingsFile.path}"
        } catch (Exception e) {
            throw new GradleException("Failed to download version mappings: ${e.message}")
        }
    }
}

repositories {
    mavenCentral()
    maven { name = "Fabric"; url = "https://maven.fabricmc.net/" }
    maven { name = "TerraformersMC"; url = "https://maven.terraformersmc.com/" }
    maven { name = "Shedaniel"; url = "https://maven.shedaniel.me/" }
    maven { url = "https://maven.architectury.dev/" }
}

import groovy.json.JsonSlurper
import groovy.json.JsonOutput

def loadVersionMappings() {
    def mappingsFile = file('version_mappings.json')
    if (!mappingsFile.exists()) {
        // Instruct the user to run the new task if the file is missing
        println "Version mappings file not found. Downloading it..."
		
		
		def apiUrl = "https://linkieapi.shedaniel.me/api/versions/all"
       
        println "Fetching latest version mappings from ${apiUrl}..."
        try {
            // Connect to the URL and get the text content
            def jsonText = new URL(apiUrl).text
            // Save the downloaded content to the local file
            mappingsFile.text = jsonText
            println "Successfully saved latest mappings to ${mappingsFile.path}"
        } catch (Exception e) {
            throw new GradleException("Failed to download version mappings: ${e.message}")
        }
		
    }
    
    def slurper = new JsonSlurper()
    def mappingsData = slurper.parseText(mappingsFile.text)
    
    def newVersionMappings = [:]
    String detectedLatestStableVersion = null // Variable to hold the latest version

    // Iterate over the array under the "fabric" key in the JSON
    mappingsData.fabric.each { versionEntry ->
        // Only process entries marked as stable to avoid using release candidates
        if (versionEntry.stable) {
            def mcVersion = versionEntry.version

            // The API returns versions newest-first, so the first stable one we find is the latest.
            if (detectedLatestStableVersion == null) {
                detectedLatestStableVersion = mcVersion
            }

            def versionDetails = [:]
            versionEntry.blocks.each { blockName, blockDetails ->
                if (blockDetails.dependencies) {
                    blockDetails.dependencies.each { dep ->
                        switch (dep.name) {
                            case "Yarn": versionDetails.yarn = dep.notation; break
                            case "Fabric Loader": versionDetails.loader = dep.notation; break
                            case "Fabric API": versionDetails.fabricApi = dep.notation; break
                            case "Cloth Config": versionDetails.clothConfig = dep.notation; break
                            case "Mod Menu": versionDetails.modMenu = dep.notation; break
                        }
                    }
                }
            }
            newVersionMappings[mcVersion] = versionDetails
        }
    }

    ext.versionMappings = newVersionMappings

    // Dynamically set the latest stable version found
    if (detectedLatestStableVersion != null) {
        ext.latestStableVersion = detectedLatestStableVersion
    } else {
        throw new GradleException("Could not determine the latest stable version from version_mappings.json.")
    }
}

// Load the version mappings using the updated function
loadVersionMappings()

// This variable now holds the default build version, which is the latest stable one.
// It can be overridden from the command line (e.g., -PtargetVersion=1.20.6)
def targetVersion = project.hasProperty('targetVersion') ? project.targetVersion : latestStableVersion

afterEvaluate {
    println "Automatically set latest stable version to: ${latestStableVersion}"
    println "Loaded version_mappings for ${versionMappings.size()} Minecraft versions (${versionMappings.keySet().join(', ')})"
    println "Current build target is: ${targetVersion}"
}


// --- The rest of the script remains largely the same ---

ext.originalFileContents = [:]

def restoreFiles() {
    if (project.ext.originalFileContents && !project.ext.originalFileContents.isEmpty()) {
        println "Restoring individually modified files"
        project.ext.originalFileContents.each { filePath, content ->
            def file = new File(filePath)
            if (content == null) {
                file.delete()
            } else {
                file.text = content
            }
        }
        project.ext.originalFileContents.clear()
    }
}

task applyVersionSpecificOverrides {
    def mainSourceDir = file("src/main/java")
    def versionSpecificDir = file("src/version_specific/${targetVersion}/java")
def backupDir = file("backup_scr/src_backup_${new Date().format('yyyyMMdd_HHmmss')}")
   
    onlyIf { versionSpecificDir.exists() }
   
    doFirst {
        restoreFiles()
        println "Applying version-specific overrides for Minecraft ${targetVersion}"
        def versionSpecificFiles = fileTree(versionSpecificDir).matching { include "**/*.java" }
        versionSpecificFiles.each { versionFile ->
            def relativePath = versionFile.path.substring(versionSpecificDir.path.length())
            def targetFile = new File(mainSourceDir, relativePath)
            if (targetFile.exists()) {
                println "Overriding: ${relativePath}"
                project.ext.originalFileContents[targetFile.path] = targetFile.text
def backupFile = new File(backupDir, relativePath)
                backupFile.parentFile.mkdirs()
                backupFile.text = targetFile.text
                targetFile.text = versionFile.text
            } else {
                println "Target file doesn't exist, creating: ${relativePath}"
                targetFile.parentFile.mkdirs()
                project.ext.originalFileContents[targetFile.path] = null
                targetFile.text = versionFile.text
            }
        }
    }
}

tasks.named('compileJava').configure {
dependsOn(editFabricModJson)
    dependsOn(applyVersionSpecificOverrides)
}

// After the build finishes, always restore the workspace to the latest stable version
gradle.buildFinished { result ->
println "\n#######################################################"
println "#################### TASK COMPLETE ####################"
println "#######################################################\n"
    restoreFiles()
updateFabricModJson(latestStableVersion)
}

task editFabricModJson {
doFirst {
        updateFabricModJson(targetVersion)
}
}

def updateFabricModJson(String version) {
    def fabricModFile = file('src/main/resources/fabric.mod.json')
    def jsonSlurper = new JsonSlurper()
    def fabricMod = jsonSlurper.parse(fabricModFile)
   
    if (!versionMappings.containsKey(version)) {
        throw new GradleException("\nUnsupported or non-stable Minecraft version: ${version}\nAvailable stable versions: ${versionMappings.keySet().join(', ')}\n")
    }
   
    fabricMod.version = project.version
    fabricMod.depends = fabricMod.depends ?: [:]
    fabricMod.depends.minecraft = "~${version}"
    fabricMod.depends["fabric-api"] = ">=${versionMappings[version].fabricApi.split(':')[2]}"
   
    fabricModFile.text = JsonOutput.prettyPrint(JsonOutput.toJson(fabricMod))

if (version == latestStableVersion){
   println "\nSuccessfully set fabric.mod.json to latest stable version ${version}\n"
}
else {
        println "\nSuccessfully updated fabric.mod.json for temporary build target ${version}\n"
}
}

tasks.named("remapJar") {
archiveBaseName = 'inventoryextended'
    archiveClassifier = "mc${targetVersion}"
}

dependencies {
    minecraft "com.mojang:minecraft:${targetVersion}"
    
    def currentMappings = versionMappings[targetVersion]
    if (currentMappings == null) {
        throw new GradleException("No mappings found for Minecraft version ${targetVersion}. Check your version_mappings.json or run the updateVersionMappings task.")
    }

    mappings currentMappings.yarn
    modImplementation currentMappings.loader
    modImplementation currentMappings.fabricApi
    
	
}